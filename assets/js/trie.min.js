// https://github.com/rtomrud/trie-mapping/
/*
MIT License
Copyright 2018 Artem Rudenko

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0})}else{obj[key]=value}return obj}
function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}
function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest()}
function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}
function _iterableToArrayLimit(arr,i){var _arr=[];var _n=!0;var _d=!1;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=!0){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=!0;_e=err}finally{try{if(!_n&&_i["return"]!=null)_i["return"]()}finally{if(_d)throw _e}}return _arr}
function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}
var valueKey="";var sizeKey="size";var hasOwnProperty=Object.prototype.hasOwnProperty;var keys=Object.keys;var key=function key(path){return path.reduce(function(key,_ref){var _ref2=_slicedToArray(_ref,1),character=_ref2[0];return key+character},"")};var value=function value(path){return path[path.length-1][1][valueKey]};var entry=function entry(path){return[key(path),value(path)]};var createIterator=function createIterator(pendingPaths,path,createIteratorValue){pendingPaths.push(path);var done=!1;var iterator={next:function next(){if(done){return{done:done,value:undefined}}
var _path$pop=path.pop(),_path$pop2=_slicedToArray(_path$pop,2),lastCharacter=_path$pop2[0],node=_path$pop2[1];if(lastCharacter==null){if(hasOwnProperty.call(node,valueKey)){path.push(["",node]);return{done:done,value:createIteratorValue(path)}}
lastCharacter=""}
if(node==null){path.push([lastCharacter,node]);var length=path.length;var i=1;var _path=_slicedToArray(path,1);var _path$=_slicedToArray(_path[0],2);lastCharacter=_path$[0];node=_path$[1];node=node[lastCharacter];while(node!=null&&i<length){path[i][1]=node;node=node[path[i][0]];i+=1}
var _path$splice=path.splice(i-1);var _path$splice2=_slicedToArray(_path$splice,1);var _path$splice2$=_slicedToArray(_path$splice2[0],2);lastCharacter=_path$splice2$[0];node=_path$splice2$[1]}
var nextCharacter=function nextCharacter(_nextCharacter,key){return key>lastCharacter&&(key<_nextCharacter||_nextCharacter===lastCharacter)&&key.length===1?key:_nextCharacter};var character=keys(node).reduce(nextCharacter,lastCharacter);while(character===lastCharacter){if(path.length===0){pendingPaths.splice(pendingPaths.indexOf(path),1);done=!0;return{done:done,value:undefined}}
var _path$pop3=path.pop();var _path$pop4=_slicedToArray(_path$pop3,2);lastCharacter=_path$pop4[0];node=_path$pop4[1];character=keys(node).reduce(nextCharacter,lastCharacter)}
path.push([character,node]);node=node[character];nextCharacter=function nextCharacter(_nextCharacter2,key){return key<_nextCharacter2&&key.length===1?key:_nextCharacter2};while(!hasOwnProperty.call(node,valueKey)){character=keys(node).reduce(nextCharacter);path.push([character,node]);node=node[character]}
path.push(["",node]);return{done:done,value:createIteratorValue(path)}}};if(Symbol&&Symbol.iterator){iterator[Symbol.iterator]=function(){return iterator}}
return iterator};var getNode=function getNode(root,key){var length=key.length;var node=root;var index=0;while(node!=null&&index<length){node=node[key.charAt(index)];index+=1}
return node};function triemap(elements){if(typeof elements!=="undefined"&&_typeof(elements)!=="object"){throw TypeError()}
var pendingPaths=[];var root=null;var trie={get root(){return root},get size(){return root[sizeKey]},clear:function clear(){root=_defineProperty({},sizeKey,0);pendingPaths.forEach(function(path){path.forEach(function(step,i){step[1]=i>0?null:root})})},delete:function _delete(){var key=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";var characters=String(key);var length=characters.length;var node=root;var ancestor=root;var ancestorCharacter=characters.charAt(0);var index=0;while(node!=null&&index<length){var currentCharacter=characters.charAt(index);if(keys(node).length>1){ancestor=node;ancestorCharacter=currentCharacter}
node=node[currentCharacter];index+=1}
if(node==null||!hasOwnProperty.call(node,valueKey)){return!1}
root[sizeKey]-=1;if(keys(node).length<=1){return delete ancestor[ancestorCharacter]}
return delete node[valueKey]},entries:function entries(){return createIterator(pendingPaths,[[null,root]],entry)},forEach:function forEach(callbackfn,thisArg){var boundCallbackfn=callbackfn.bind(thisArg);var _createIterator=createIterator(pendingPaths,[[null,root]],entry),next=_createIterator.next;var _next=next(),done=_next.done,_next$value=_next.value;_next$value=_next$value===void 0?[]:_next$value;var _next$value2=_slicedToArray(_next$value,2),key=_next$value2[0],value=_next$value2[1];while(!done){boundCallbackfn(value,key,trie);var _next2=next();done=_next2.done;var _next2$value=_next2.value;_next2$value=_next2$value===void 0?[]:_next2$value;var _next2$value2=_slicedToArray(_next2$value,2);key=_next2$value2[0];value=_next2$value2[1]}},get:function get(){var key=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";var node=getNode(root,String(key));return node==null?undefined:node[valueKey]},getPrefixedWith:function getPrefixedWith(){var prefix=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";var characters=String(prefix);var node=getNode(root,characters);if(node==null){return[]}
var prefixedWith=[];var _createIterator2=createIterator(pendingPaths,[[null,node]],entry),next=_createIterator2.next;var _next3=next(),done=_next3.done,_next3$value=_next3.value;_next3$value=_next3$value===void 0?[]:_next3$value;var _next3$value2=_slicedToArray(_next3$value,2),suffix=_next3$value2[0],value=_next3$value2[1];while(!done){prefixedWith.push([characters+suffix,value]);var _next4=next();done=_next4.done;var _next4$value=_next4.value;_next4$value=_next4$value===void 0?[]:_next4$value;var _next4$value2=_slicedToArray(_next4$value,2);suffix=_next4$value2[0];value=_next4$value2[1]}
return prefixedWith},getPrefixesOf:function getPrefixesOf(){var string=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";var characters=String(string);var length=characters.length;var prefixes=[];var node=root;var index=0;while(node!=null&&index<=length){if(hasOwnProperty.call(node,valueKey)){prefixes.push([characters.slice(0,index),node[valueKey]])}
node=node[characters.charAt(index)];index+=1}
return prefixes},has:function has(){var key=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";var node=getNode(root,String(key));return node!=null&&hasOwnProperty.call(node,valueKey)},keys:function keys(){return createIterator(pendingPaths,[[null,root]],key)},set:function set(){var key=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";var value=arguments.length>1?arguments[1]:undefined;var characters=String(key);var length=characters.length;var node=root;var parent=node;var index=0;while(index<length){node=node[characters.charAt(index)];if(node==null){node={};parent[characters.charAt(index)]=node}
parent=node;index+=1}
if(!hasOwnProperty.call(node,valueKey)){root[sizeKey]+=1}
node[valueKey]=value;return trie},values:function values(){return createIterator(pendingPaths,[[null,root]],value)}};if(Symbol&&Symbol.iterator){trie[Symbol.iterator]=function(){return createIterator(pendingPaths,[[null,root]],entry)}}
if(Array.isArray(elements)){root=_defineProperty({},sizeKey,0);var set=trie.set;Array.prototype.forEach.call(elements,function(entry){return set(entry[0],entry[1])})}else if(elements!=null&&Symbol&&Symbol.iterator in elements){root=_defineProperty({},sizeKey,0);var _set=trie.set;var iterator=elements[Symbol.iterator]();var _iterator$next=iterator.next(),done=_iterator$next.done,_value=_iterator$next.value;while(!done){if(_typeof(_value)!=="object"){throw TypeError()}
_set(_value[0],_value[1]);var _iterator$next2=iterator.next();done=_iterator$next2.done;_value=_iterator$next2.value}}else{root=elements||{};root[sizeKey]=root[sizeKey]||0}
return trie}